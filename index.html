<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Ensures proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Daily Jigsaw Puzzle – Mobile Optimized</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    /* Reference image styling */
    #reference {
      margin-bottom: 10px;
    }
    #reference img {
      border: 1px solid #333;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    }
    /* Timer & message styling */
    #timer, #message {
      margin-top: 10px;
      font-size: 1.2em;
    }
    /* The puzzle container will have its dimensions set via JavaScript */
    #puzzle-container {
      margin: 0 auto;
      border: 2px solid #333;
      background: #eee;
      overflow: hidden;
      position: relative;
    }
    /* Each jigsaw piece as a canvas */
    canvas.piece {
      position: absolute;
      cursor: grab;
      transition: left 0.2s, top 0.2s;
      touch-action: none; /* Prevents default touch scrolling */
    }
    canvas.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }
    canvas.correct {
      box-shadow: 0 0 8px green;
    }
    /* Confetti overlay */
    #confetti-container {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
    }
    .confetti {
      position: absolute;
      width: 8px;
      height: 8px;
      opacity: 0.9;
      animation: confettiFall 2s linear forwards;
    }
    @keyframes confettiFall {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(300px) rotate(360deg);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <h1>Daily Jigsaw Puzzle – Mobile Optimized</h1>

  <!-- Reference image thumbnail -->
  <div id="reference">
    <strong>Reference:</strong><br>
    <img id="reference-image" alt="Reference puzzle" width="100" height="100">
  </div>

  <!-- Timer display -->
  <div id="timer">Time: 0s</div>

  <!-- Puzzle container (its width/height is set dynamically) -->
  <div id="puzzle-container">
    <div id="confetti-container"></div>
  </div>

  <!-- Completion message -->
  <div id="message"></div>

  <script>
    // -------------------------------------------------------------
    // 1) CONFIGURATION & MOBILE ADAPTATION
    // -------------------------------------------------------------
    // Use smaller sizes for narrow screens
    let baseSize = 400; // default puzzle area (without bumps)
    let bumpSize = 20;  // default bump size
    if (window.innerWidth < 480) {
      baseSize = 300; // smaller puzzle area for mobile
      bumpSize = 15;  // proportionately smaller bumps
    }
    const rows = 4, cols = 4;
    const pieceWidth = baseSize / cols;
    const pieceHeight = baseSize / rows;
    // The container needs to be big enough to hold the bumps on all sides.
    const containerSize = baseSize + 2 * bumpSize;

    // Set the puzzle container dimensions dynamically.
    const container = document.getElementById("puzzle-container");
    container.style.width = containerSize + "px";
    container.style.height = containerSize + "px";

    // -------------------------------------------------------------
    // 2) DAILY SEED: Puzzle changes every day.
    // -------------------------------------------------------------
    const todayStr = new Date().toISOString().split('T')[0];
    let seed = 0;
    for (let i = 0; i < todayStr.length; i++) {
      seed += todayStr.charCodeAt(i);
    }
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    const random = mulberry32(seed);

    // -------------------------------------------------------------
    // 3) TIMER WITH LOCAL STORAGE
    // -------------------------------------------------------------
    let startTime = Date.now();
    let elapsedTime = 0;
    const timerDisplay = document.getElementById("timer");
    const timerKey = "mobilePuzzleTimer-" + todayStr;
    const savedElapsed = localStorage.getItem(timerKey);
    if (savedElapsed) {
      elapsedTime = parseInt(savedElapsed, 10);
      startTime = Date.now() - elapsedTime;
    }
    const timerInterval = setInterval(() => {
      elapsedTime = Date.now() - startTime;
      timerDisplay.innerText = "Time: " + Math.floor(elapsedTime / 1000) + "s";
      localStorage.setItem(timerKey, elapsedTime);
    }, 1000);

    // -------------------------------------------------------------
    // 4) GENERATE THE BASE IMAGE (GRADIENT + RANDOM CIRCLES)
    // -------------------------------------------------------------
    function generateBaseImage() {
      const canvas = document.createElement("canvas");
      canvas.width = baseSize;
      canvas.height = baseSize;
      const ctx = canvas.getContext("2d");

      // Gradient background
      const grad = ctx.createLinearGradient(0, 0, baseSize, baseSize);
      const color1 = `hsl(${Math.floor(random()*360)}, 70%, 70%)`;
      const color2 = `hsl(${Math.floor(random()*360)}, 70%, 70%)`;
      grad.addColorStop(0, color1);
      grad.addColorStop(1, color2);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, baseSize, baseSize);

      // Random circles
      for (let i = 0; i < 10; i++) {
        ctx.beginPath();
        const x = random() * baseSize;
        const y = random() * baseSize;
        const radius = random() * 40 + 10;
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fillStyle = `hsla(${Math.floor(random()*360)}, 70%, 50%, 0.5)`;
        ctx.fill();
      }
      return canvas;
    }
    const baseImageCanvas = generateBaseImage();
    document.getElementById("reference-image").src = baseImageCanvas.toDataURL();

    // -------------------------------------------------------------
    // 5) DEFINE JIGSAW EDGES (Complementary for adjacent pieces)
    // -------------------------------------------------------------
    const pieces = [];
    for (let r = 0; r < rows; r++) {
      pieces[r] = [];
      for (let c = 0; c < cols; c++) {
        const piece = { row: r, col: c, currentRow: r, currentCol: c, edges: {}, locked: false };
        // Top edge: flat on top row; else inverse of piece above.
        piece.edges.top = (r === 0) ? 0 : -pieces[r-1][c].edges.bottom;
        // Left edge: flat on left column; else inverse of piece to the left.
        piece.edges.left = (c === 0) ? 0 : -pieces[r][c-1].edges.right;
        // Right edge: flat on right border; else random.
        piece.edges.right = (c === cols - 1) ? 0 : (random() > 0.5 ? 1 : -1);
        // Bottom edge: flat on bottom row; else random.
        piece.edges.bottom = (r === rows - 1) ? 0 : (random() > 0.5 ? 1 : -1);
        pieces[r][c] = piece;
      }
    }

    // -------------------------------------------------------------
    // 6) DRAW THE JIGSAW SHAPE (Offscreen Canvas, cut-out piece)
    // -------------------------------------------------------------
    function drawJigsawShape(ctx, edges, w, h, bump) {
      ctx.beginPath();
      // Top edge
      const topThird = w / 3;
      ctx.moveTo(0, 0);
      ctx.lineTo(topThird, 0);
      if (edges.top !== 0) {
        ctx.bezierCurveTo(
          topThird + topThird/4, edges.top * bump,
          2*topThird - topThird/4, edges.top * bump,
          2*topThird, 0
        );
      }
      ctx.lineTo(w, 0);
      // Right edge
      const rightThird = h / 3;
      ctx.lineTo(w, rightThird);
      if (edges.right !== 0) {
        ctx.bezierCurveTo(
          w + edges.right * bump, rightThird + rightThird/4,
          w + edges.right * bump, 2*rightThird - rightThird/4,
          w, 2*rightThird
        );
      }
      ctx.lineTo(w, h);
      // Bottom edge
      const bottomThird = w / 3;
      ctx.lineTo(w - bottomThird, h);
      if (edges.bottom !== 0) {
        ctx.bezierCurveTo(
          w - bottomThird - bottomThird/4, h + edges.bottom * bump,
          bottomThird + bottomThird/4, h + edges.bottom * bump,
          bottomThird, h
        );
      }
      ctx.lineTo(0, h);
      // Left edge
      const leftThird = h / 3;
      ctx.lineTo(0, h - leftThird);
      if (edges.left !== 0) {
        ctx.bezierCurveTo(
          edges.left * bump, h - leftThird - leftThird/4,
          edges.left * bump, leftThird + leftThird/4,
          0, leftThird
        );
      }
      ctx.lineTo(0, 0);
      ctx.closePath();
    }

    // -------------------------------------------------------------
    // 7) LOAD / SCRAMBLE PIECE POSITIONS (with localStorage)
    // -------------------------------------------------------------
    const storageKey = "mobilePuzzleState-" + todayStr;
    let savedState = localStorage.getItem(storageKey);
    let scramblePositions = [];
    if (savedState) {
      scramblePositions = JSON.parse(savedState);
    } else {
      // Build an array of all positions then shuffle them using our seeded random.
      const positions = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          positions.push({ row: r, col: c });
        }
      }
      for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
      }
      scramblePositions = positions.map((p, index) => {
        const r = Math.floor(index / cols);
        const c = index % cols;
        return { r: r, c: c, currentRow: p.row, currentCol: p.col };
      });
    }

    // -------------------------------------------------------------
    // 8) BUILD THE PIECES AND INSERT INTO THE DOM
    // -------------------------------------------------------------
    const confettiContainer = document.getElementById("confetti-container");
    const piecesArray = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const piece = pieces[r][c];
        // Apply saved/scrambled position
        const match = scramblePositions.find(p => p.r === r && p.c === c);
        if (match) {
          piece.currentRow = match.currentRow;
          piece.currentCol = match.currentCol;
        }
        // Create an offscreen canvas to "cut out" the piece.
        const offCanvas = document.createElement("canvas");
        offCanvas.width = pieceWidth + 2 * bumpSize;
        offCanvas.height = pieceHeight + 2 * bumpSize;
        const offCtx = offCanvas.getContext("2d");
        offCtx.save();
        offCtx.translate(bumpSize, bumpSize);
        drawJigsawShape(offCtx, piece.edges, pieceWidth, pieceHeight, bumpSize);
        offCtx.clip();
        offCtx.drawImage(
          baseImageCanvas,
          c * pieceWidth, r * pieceHeight,
          pieceWidth, pieceHeight,
          0, 0,
          pieceWidth, pieceHeight
        );
        offCtx.restore();
        // Create the DOM canvas for the piece.
        const domCanvas = document.createElement("canvas");
        domCanvas.width = offCanvas.width;
        domCanvas.height = offCanvas.height;
        domCanvas.className = "piece";
        const domCtx = domCanvas.getContext("2d");
        domCtx.drawImage(offCanvas, 0, 0);
        piece.canvas = domCanvas;
        piecesArray.push(piece);
        container.appendChild(domCanvas);
        // Position the piece with a negative offset so the bumps line up.
        positionPiece(piece);
        // Add drag events.
        addDragEvents(piece);
      }
    }

    // -------------------------------------------------------------
    // 9) POSITIONING FUNCTION (negative bump offset)
    // -------------------------------------------------------------
    function positionPiece(piece) {
      piece.canvas.style.left = (piece.currentCol * pieceWidth - bumpSize) + "px";
      piece.canvas.style.top  = (piece.currentRow * pieceHeight - bumpSize) + "px";
    }

    // -------------------------------------------------------------
    // 10) DRAG-AND-DROP WITH GRID SNAPPING (swap if occupied)
    // -------------------------------------------------------------
    function addDragEvents(piece) {
      let offsetX = 0, offsetY = 0;
      let isDragging = false;

      piece.canvas.addEventListener("pointerdown", (e) => {
        if (piece.locked) return;
        isDragging = true;
        piece.canvas.classList.add("dragging");
        piece.canvas.setPointerCapture(e.pointerId);
        const rect = piece.canvas.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
      });

      piece.canvas.addEventListener("pointermove", (e) => {
        if (!isDragging) return;
        const containerRect = container.getBoundingClientRect();
        const newLeft = e.clientX - containerRect.left - offsetX;
        const newTop = e.clientY - containerRect.top - offsetY;
        piece.canvas.style.left = newLeft + "px";
        piece.canvas.style.top = newTop + "px";
      });

      piece.canvas.addEventListener("pointerup", (e) => {
        if (!isDragging) return;
        isDragging = false;
        piece.canvas.classList.remove("dragging");
        const leftPos = parseInt(piece.canvas.style.left);
        const topPos = parseInt(piece.canvas.style.top);
        // Calculate target grid cell (add bumpSize to offset our negative placement)
        let targetCol = Math.round((leftPos + bumpSize) / pieceWidth);
        let targetRow = Math.round((topPos + bumpSize) / pieceHeight);
        targetCol = Math.max(0, Math.min(cols - 1, targetCol));
        targetRow = Math.max(0, Math.min(rows - 1, targetRow));
        const other = piecesArray.find(p =>
          p !== piece &&
          p.currentRow === targetRow &&
          p.currentCol === targetCol
        );
        if (other) {
          const tmpRow = piece.currentRow;
          const tmpCol = piece.currentCol;
          piece.currentRow = other.currentRow;
          piece.currentCol = other.currentCol;
          other.currentRow = tmpRow;
          other.currentCol = tmpCol;
          positionPiece(piece);
          positionPiece(other);
          updatePieceHighlight(piece);
          updatePieceHighlight(other);
        } else {
          piece.currentRow = targetRow;
          piece.currentCol = targetCol;
          positionPiece(piece);
          updatePieceHighlight(piece);
        }
        savePuzzleState();
        if (checkSolved()) puzzleSolved();
      });
    }

    // -------------------------------------------------------------
    // 11) VISUAL HIGHLIGHT FOR CORRECT PIECES (and lock them)
    // -------------------------------------------------------------
    function updatePieceHighlight(piece) {
      if (piece.currentRow === piece.row && piece.currentCol === piece.col) {
        piece.canvas.classList.add("correct");
        piece.locked = true;
      } else {
        piece.canvas.classList.remove("correct");
        piece.locked = false;
      }
    }

    // -------------------------------------------------------------
    // 12) SAVE PUZZLE STATE (to localStorage)
    // -------------------------------------------------------------
    function savePuzzleState() {
      const stateArray = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const piece = pieces[r][c];
          stateArray.push({
            r: r, c: c,
            currentRow: piece.currentRow,
            currentCol: piece.currentCol
          });
        }
      }
      localStorage.setItem(storageKey, JSON.stringify(stateArray));
    }

    // -------------------------------------------------------------
    // 13) CHECK IF THE PUZZLE IS SOLVED
    // -------------------------------------------------------------
    function checkSolved() {
      return piecesArray.every(p => p.currentRow === p.row && p.currentCol === p.col);
    }

    // -------------------------------------------------------------
    // 14) PUZZLE SOLVED: Stop Timer, Show Message, Confetti
    // -------------------------------------------------------------
    function puzzleSolved() {
      clearInterval(timerInterval);
      const seconds = Math.floor(elapsedTime / 1000);
      document.getElementById("message").innerText =
        "Congratulations! Puzzle solved in " + seconds + " seconds.";
      launchConfetti();
    }

    // -------------------------------------------------------------
    // 15) CONFETTI ANIMATION
    // -------------------------------------------------------------
    function launchConfetti() {
      const colors = ["#FFC107", "#E91E63", "#03A9F4", "#4CAF50", "#FF5722"];
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement("div");
        confetti.className = "confetti";
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = Math.random() * containerSize + "px";
        confetti.style.animationDelay = Math.random() * 1 + "s";
        confettiContainer.appendChild(confetti);
        confetti.addEventListener("animationend", () => {
          confettiContainer.removeChild(confetti);
        });
      }
    }

    // Initial highlight check
    piecesArray.forEach(updatePieceHighlight);
  </script>
</body>
</html>
