<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Daily Jigsaw Puzzle – Irregular Pieces</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 20px;
    }
    #puzzle-container {
      width: 400px;
      height: 400px;
      margin: 0 auto;
      position: relative;
      border: 2px solid #333;
      box-shadow: 2px 2px 12px rgba(0,0,0,0.3);
      background: #eee;
    }
    canvas.piece {
      position: absolute;
      cursor: pointer;
      transition: top 0.3s, left 0.3s;
    }
    .selected {
      outline: 3px solid red;
    }
    #message {
      margin-top: 20px;
      font-size: 1.2em;
      color: green;
    }
    #instructions {
      margin-bottom: 10px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>Daily Jigsaw Puzzle – Irregular Pieces</h1>
  <div id="instructions">Click on two pieces to swap them.</div>
  <div id="puzzle-container"></div>
  <div id="message"></div>

  <script>
    window.onload = function() {
      // Puzzle configuration
      const containerSize = 400;            // overall puzzle size in pixels
      const rows = 4, cols = 4;               // grid dimensions
      const pieceWidth = containerSize / cols; // e.g. 100px per piece
      const pieceHeight = containerSize / rows; // 100px per piece
      const bumpSize = pieceWidth * 0.2;      // size of bumps (20% of piece width)

      // Use today's date (YYYY-MM-DD) as a seed so that the puzzle is the same for everyone.
      let today = new Date();
      let dateStr = today.toISOString().split('T')[0];
      let seed = 0;
      for (let i = 0; i < dateStr.length; i++) {
        seed += dateStr.charCodeAt(i);
      }
      // A simple seeded random generator (mulberry32)
      function mulberry32(a) {
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
      }
      const random = mulberry32(seed);

      // Generate a base image procedurally (a gradient background with random circles)
      function generateImage(random) {
        let canvas = document.createElement("canvas");
        canvas.width = containerSize;
        canvas.height = containerSize;
        let ctx = canvas.getContext("2d");
        // Create a linear gradient background.
        let grad = ctx.createLinearGradient(0, 0, containerSize, containerSize);
        let color1 = `hsl(${Math.floor(random()*360)}, 70%, 70%)`;
        let color2 = `hsl(${Math.floor(random()*360)}, 70%, 70%)`;
        grad.addColorStop(0, color1);
        grad.addColorStop(1, color2);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, containerSize, containerSize);
        // Draw a few semi-transparent circles.
        for (let i = 0; i < 10; i++) {
          ctx.beginPath();
          let x = random() * containerSize;
          let y = random() * containerSize;
          let radius = random() * 40 + 10;
          ctx.arc(x, y, radius, 0, 2 * Math.PI);
          ctx.fillStyle = `hsla(${Math.floor(random()*360)}, 70%, 50%, 0.5)`;
          ctx.fill();
        }
        return canvas;
      }
      const baseImageCanvas = generateImage(random);

      // Build a grid of pieces and assign each piece “edge types.”
      // For each edge: 0 = flat (border), 1 = tab (bump out), -1 = blank (bump in).
      let pieces = [];
      for (let r = 0; r < rows; r++) {
        pieces[r] = [];
        for (let c = 0; c < cols; c++) {
          let piece = { row: r, col: c, currentRow: r, currentCol: c, edges: {} };
          // Top edge: if on the top row, flat; otherwise, the inverse of the piece above's bottom edge.
          if (r === 0) {
            piece.edges.top = 0;
          } else {
            piece.edges.top = -pieces[r-1][c].edges.bottom;
          }
          // Left edge: if on the left, flat; otherwise, inverse of left neighbor's right edge.
          if (c === 0) {
            piece.edges.left = 0;
          } else {
            piece.edges.left = -pieces[r][c-1].edges.right;
          }
          // Right edge: if on the right border, flat; else randomly choose tab (1) or blank (-1).
          if (c === cols - 1) {
            piece.edges.right = 0;
          } else {
            piece.edges.right = (random() > 0.5 ? 1 : -1);
          }
          // Bottom edge: if on the bottom border, flat; else randomly choose tab (1) or blank (-1).
          if (r === rows - 1) {
            piece.edges.bottom = 0;
          } else {
            piece.edges.bottom = (random() > 0.5 ? 1 : -1);
          }
          pieces[r][c] = piece;
        }
      }

      // Draw a jigsaw piece shape on a canvas context.
      // The piece is drawn in a canvas sized to (pieceWidth + 2*bumpSize) x (pieceHeight + 2*bumpSize).
      // The drawing starts at (bumpSize, bumpSize) so that bumps have room to extend.
      function drawJigsawPiece(ctx, edges, pieceX, pieceY, pieceWidth, pieceHeight, bumpSize) {
        ctx.beginPath();
        let offset = bumpSize;
        // Start at top-left
        ctx.moveTo(offset, offset);

        // --- Top edge ---
        let third = pieceWidth / 3;
        ctx.lineTo(offset + third, offset);
        if (edges.top !== 0) {
          ctx.bezierCurveTo(
            offset + third + third/4, offset + edges.top * bumpSize,
            offset + 2*third - third/4, offset + edges.top * bumpSize,
            offset + 2*third, offset
          );
        }
        ctx.lineTo(offset + pieceWidth, offset);

        // --- Right edge ---
        third = pieceHeight / 3;
        ctx.lineTo(offset + pieceWidth, offset + third);
        if (edges.right !== 0) {
          ctx.bezierCurveTo(
            offset + pieceWidth + edges.right * bumpSize, offset + third + third/4,
            offset + pieceWidth + edges.right * bumpSize, offset + 2*third - third/4,
            offset + pieceWidth, offset + 2*third
          );
        }
        ctx.lineTo(offset + pieceWidth, offset + pieceHeight);

        // --- Bottom edge ---
        third = pieceWidth / 3;
        ctx.lineTo(offset + pieceWidth - third, offset + pieceHeight);
        if (edges.bottom !== 0) {
          ctx.bezierCurveTo(
            offset + pieceWidth - third - third/4, offset + pieceHeight + edges.bottom * bumpSize,
            offset + third + third/4, offset + pieceHeight + edges.bottom * bumpSize,
            offset + third, offset + pieceHeight
          );
        }
        ctx.lineTo(offset, offset + pieceHeight);

        // --- Left edge ---
        third = pieceHeight / 3;
        ctx.lineTo(offset, offset + pieceHeight - third);
        if (edges.left !== 0) {
          ctx.bezierCurveTo(
            offset + edges.left * bumpSize, offset + pieceHeight - third - third/4,
            offset + edges.left * bumpSize, offset + third + third/4,
            offset, offset + third
          );
        }
        ctx.lineTo(offset, offset);
        ctx.closePath();
      }

      // Create the puzzle pieces as individual canvas elements and scramble them.
      const container = document.getElementById("puzzle-container");
      container.style.position = "relative";
      let piecesArray = []; // a flat list of all pieces

      // Create an array of grid positions and shuffle it (using our seeded random).
      let positions = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          positions.push({row: r, col: c});
        }
      }
      for (let i = positions.length - 1; i > 0; i--) {
        let j = Math.floor(random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
      }

      // For each piece in our grid, create its canvas and draw it.
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          let piece = pieces[r][c];
          // Create a canvas element for the piece.
          let canvas = document.createElement("canvas");
          canvas.width = pieceWidth + 2*bumpSize;
          canvas.height = pieceHeight + 2*bumpSize;
          canvas.className = "piece";
          // Assign a scrambled position from the shuffled positions.
          let pos = positions.pop();
          piece.currentRow = pos.row;
          piece.currentCol = pos.col;
          // Position the canvas inside the container.
          // (Subtract bumpSize so that bumps extending beyond the grid still align roughly.)
          canvas.style.left = (piece.currentCol * pieceWidth - bumpSize) + "px";
          canvas.style.top = (piece.currentRow * pieceHeight - bumpSize) + "px";

          // Draw the jigsaw shape and clip to it.
          let ctx = canvas.getContext("2d");
          drawJigsawPiece(ctx, piece.edges, c * pieceWidth, r * pieceHeight, pieceWidth, pieceHeight, bumpSize);
          ctx.save();
          ctx.clip();
          // Draw the corresponding portion of the base image.
          // The source rectangle on the base image:
          // x = c*pieceWidth, y = r*pieceHeight, width = pieceWidth, height = pieceHeight.
          // Draw it at (bumpSize, bumpSize) inside the piece canvas.
          ctx.drawImage(baseImageCanvas, c * pieceWidth, r * pieceHeight, pieceWidth, pieceHeight, bumpSize, bumpSize, pieceWidth, pieceHeight);
          ctx.restore();
          // Optionally stroke the edge for visual clarity.
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          ctx.stroke();

          piece.canvas = canvas;
          piecesArray.push(piece);
          container.appendChild(canvas);

          // Add a click event so the player can select pieces to swap.
          canvas.addEventListener("click", function() { pieceClicked(piece); });
        }
      }

      // Allow the player to click two pieces to swap their positions.
      let firstSelected = null;
      function pieceClicked(piece) {
        if (!firstSelected) {
          firstSelected = piece;
          piece.canvas.classList.add("selected");
        } else if (firstSelected === piece) {
          piece.canvas.classList.remove("selected");
          firstSelected = null;
        } else {
          swapPieces(firstSelected, piece);
          firstSelected.canvas.classList.remove("selected");
          firstSelected = null;
          if (checkSolved()) {
            document.getElementById("message").innerText = "Congratulations! Puzzle solved!";
          }
        }
      }

      // Swap the grid positions of two pieces.
      function swapPieces(piece1, piece2) {
        let tempRow = piece1.currentRow;
        let tempCol = piece1.currentCol;
        piece1.currentRow = piece2.currentRow;
        piece1.currentCol = piece2.currentCol;
        piece2.currentRow = tempRow;
        piece2.currentCol = tempCol;
        piece1.canvas.style.left = (piece1.currentCol * pieceWidth - bumpSize) + "px";
        piece1.canvas.style.top = (piece1.currentRow * pieceHeight - bumpSize) + "px";
        piece2.canvas.style.left = (piece2.currentCol * pieceWidth - bumpSize) + "px";
        piece2.canvas.style.top = (piece2.currentRow * pieceHeight - bumpSize) + "px";
      }

      // Check if all pieces are in their correct (solved) grid positions.
      function checkSolved() {
        for (let piece of piecesArray) {
          if (piece.currentRow !== piece.row || piece.currentCol !== piece.col) {
            return false;
          }
        }
        return true;
      }
    };
  </script>
</body>
</html>
