<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Daily Jigsaw Puzzle – Irregular Pieces (Revised)</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 20px;
    }

    /* Container now bigger to accommodate piece bumps */
    #puzzle-container {
      /* 400 + 2*bumpSize = 400 + 2*(pieceWidth*0.2) = 400 + 40 = 440 */
      width: 440px;
      height: 440px;
      margin: 0 auto;
      position: relative;
      border: 2px solid #333;
      box-shadow: 2px 2px 12px rgba(0,0,0,0.3);
      background: #eee;
    }

    canvas.piece {
      position: absolute;
      cursor: pointer;
      transition: top 0.3s, left 0.3s;
    }

    .selected {
      outline: 3px solid red;
    }

    #message {
      margin-top: 20px;
      font-size: 1.2em;
      color: green;
    }

    #instructions {
      margin-bottom: 10px;
      font-style: italic;
    }

    #reference {
      margin-bottom: 10px;
    }

    #reference img {
      border: 1px solid #333;
      box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <h1>Daily Jigsaw Puzzle – Irregular Pieces</h1>

  <!-- Small reference image for players -->
  <div id="reference">
    <strong>Reference:</strong><br>
    <img id="reference-image" alt="Reference puzzle" />
  </div>

  <div id="instructions">Click on two pieces to swap them.</div>
  <div id="puzzle-container"></div>
  <div id="message"></div>

  <script>
    window.onload = function() {
      // Puzzle configuration
      const baseSize = 400;                 // final puzzle area (without bumps)
      const rows = 4, cols = 4;             // grid dimensions
      const pieceWidth = baseSize / cols;   // e.g., 100px per piece
      const pieceHeight = baseSize / rows;  // e.g., 100px per piece
      const bumpSize = pieceWidth * 0.2;    // size of bumps (~20% of piece width)

      // Because we allow up to bumpSize around each edge, the container is baseSize + 2*bumpSize in both dimensions.
      const containerSize = baseSize + 2 * bumpSize;

      // Use today's date (YYYY-MM-DD) as a seed for consistent daily puzzles.
      let today = new Date();
      let dateStr = today.toISOString().split('T')[0];
      let seed = 0;
      for (let i = 0; i < dateStr.length; i++) {
        seed += dateStr.charCodeAt(i);
      }

      // A simple seeded random generator (mulberry32)
      function mulberry32(a) {
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
      }
      const random = mulberry32(seed);

      // Generate a base image procedurally (a gradient background with random circles)
      function generateImage(random) {
        let canvas = document.createElement("canvas");
        canvas.width = baseSize;
        canvas.height = baseSize;
        let ctx = canvas.getContext("2d");

        // Create a linear gradient background.
        let grad = ctx.createLinearGradient(0, 0, baseSize, baseSize);
        let color1 = `hsl(${Math.floor(random()*360)}, 70%, 70%)`;
        let color2 = `hsl(${Math.floor(random()*360)}, 70%, 70%)`;
        grad.addColorStop(0, color1);
        grad.addColorStop(1, color2);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, baseSize, baseSize);

        // Draw a few semi-transparent circles.
        for (let i = 0; i < 10; i++) {
          ctx.beginPath();
          let x = random() * baseSize;
          let y = random() * baseSize;
          let radius = random() * 40 + 10;
          ctx.arc(x, y, radius, 0, 2 * Math.PI);
          ctx.fillStyle = `hsla(${Math.floor(random()*360)}, 70%, 50%, 0.5)`;
          ctx.fill();
        }
        return canvas;
      }
      const baseImageCanvas = generateImage(random);

      // Display a small reference image (thumbnail) so players know the goal.
      const referenceImg = document.getElementById("reference-image");
      referenceImg.src = baseImageCanvas.toDataURL();
      referenceImg.width = 100;   // smaller thumbnail
      referenceImg.height = 100;

      // Build a 2D array describing each puzzle piece, including edge types.
      let pieces = [];
      for (let r = 0; r < rows; r++) {
        pieces[r] = [];
        for (let c = 0; c < cols; c++) {
          let piece = { row: r, col: c, currentRow: r, currentCol: c, edges: {} };
          // Top edge: if on the top row, flat; otherwise, inverse of above piece's bottom edge.
          if (r === 0) {
            piece.edges.top = 0;
          } else {
            piece.edges.top = -pieces[r-1][c].edges.bottom;
          }
          // Left edge: if on the left, flat; otherwise, inverse of left piece's right edge.
          if (c === 0) {
            piece.edges.left = 0;
          } else {
            piece.edges.left = -pieces[r][c-1].edges.right;
          }
          // Right edge: if on the right border, flat; else randomly choose tab (1) or blank (-1).
          if (c === cols - 1) {
            piece.edges.right = 0;
          } else {
            piece.edges.right = (random() > 0.5 ? 1 : -1);
          }
          // Bottom edge: if on the bottom border, flat; else randomly choose tab (1) or blank (-1).
          if (r === rows - 1) {
            piece.edges.bottom = 0;
          } else {
            piece.edges.bottom = (random() > 0.5 ? 1 : -1);
          }
          pieces[r][c] = piece;
        }
      }

      // Function to draw the jigsaw shape for a piece onto a canvas context.
      function drawJigsawPiece(ctx, edges, width, height, bump) {
        ctx.beginPath();
        // We'll start at (0,0) and draw around the piece within [0..width, 0..height].
        // Bumps are drawn as bezier curves that go in or out by 'bump'.
        let xMax = width, yMax = height;

        // --- Top edge ---
        let topThird = xMax / 3;
        ctx.moveTo(0, 0);
        ctx.lineTo(topThird, 0);
        if (edges.top !== 0) {
          ctx.bezierCurveTo(
            topThird + topThird/4, edges.top * bump,
            2*topThird - topThird/4, edges.top * bump,
            2*topThird, 0
          );
        }
        ctx.lineTo(xMax, 0);

        // --- Right edge ---
        let rightThird = yMax / 3;
        ctx.lineTo(xMax, rightThird);
        if (edges.right !== 0) {
          ctx.bezierCurveTo(
            xMax + edges.right * bump, rightThird + rightThird/4,
            xMax + edges.right * bump, 2*rightThird - rightThird/4,
            xMax, 2*rightThird
          );
        }
        ctx.lineTo(xMax, yMax);

        // --- Bottom edge ---
        let bottomThird = xMax / 3;
        ctx.lineTo(xMax - bottomThird, yMax);
        if (edges.bottom !== 0) {
          ctx.bezierCurveTo(
            xMax - bottomThird - bottomThird/4, yMax + edges.bottom * bump,
            bottomThird + bottomThird/4, yMax + edges.bottom * bump,
            bottomThird, yMax
          );
        }
        ctx.lineTo(0, yMax);

        // --- Left edge ---
        let leftThird = yMax / 3;
        ctx.lineTo(0, yMax - leftThird);
        if (edges.left !== 0) {
          ctx.bezierCurveTo(
            edges.left * bump, yMax - leftThird - leftThird/4,
            edges.left * bump, leftThird + leftThird/4,
            0, leftThird
          );
        }
        ctx.lineTo(0, 0);

        ctx.closePath();
      }

      // Prepare the container (now 440×440 so bumps fit fully inside).
      const container = document.getElementById("puzzle-container");
      container.style.width = containerSize + "px";
      container.style.height = containerSize + "px";

      // Create an array of all puzzle positions, then shuffle them for the scrambled layout.
      let positions = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          positions.push({row: r, col: c});
        }
      }
      for (let i = positions.length - 1; i > 0; i--) {
        let j = Math.floor(random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
      }

      // Flatten the pieces into a single array for easier iteration.
      let piecesArray = [];

      // Create a canvas for each piece and position it according to the scrambled layout.
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          let piece = pieces[r][c];
          // Create a canvas element for the piece. 
          // We'll give it the base piece size plus some extra space for the bumps.
          let canvas = document.createElement("canvas");
          canvas.width = pieceWidth;
          canvas.height = pieceHeight;
          canvas.className = "piece";

          // Pull a scrambled position from the shuffled array.
          let scrambledPos = positions.pop();
          piece.currentRow = scrambledPos.row;
          piece.currentCol = scrambledPos.col;

          // Position the canvas inside the container. 
          // Shift everything by +bumpSize so the top/left bumps fit in the container.
          canvas.style.left = (piece.currentCol * pieceWidth + bumpSize) + "px";
          canvas.style.top = (piece.currentRow * pieceHeight + bumpSize) + "px";

          let ctx = canvas.getContext("2d");

          // Draw the jigsaw shape path:
          drawJigsawPiece(ctx, piece.edges, pieceWidth, pieceHeight, bumpSize);

          // Clip to the shape:
          ctx.save();
          ctx.clip();

          // Draw the correct portion of the base image:
          // The piece's correct position is (c, r). 
          // We'll grab that portion from baseImageCanvas and draw it onto this piece.
          ctx.drawImage(
            baseImageCanvas, 
            c * pieceWidth,       // source x
            r * pieceHeight,      // source y
            pieceWidth, 
            pieceHeight, 
            0,                    // dest x
            0,                    // dest y
            pieceWidth, 
            pieceHeight
          );

          // Restore clipping, then optionally stroke the outline for clarity:
          ctx.restore();
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          ctx.stroke();

          piece.canvas = canvas;
          piecesArray.push(piece);
          container.appendChild(canvas);

          // Add click event for swapping pieces
          canvas.addEventListener("click", function() {
            pieceClicked(piece);
          });
        }
      }

      let firstSelected = null;
      function pieceClicked(piece) {
        if (!firstSelected) {
          // Select the first piece
          firstSelected = piece;
          piece.canvas.classList.add("selected");
        } else if (firstSelected === piece) {
          // If the same piece is clicked again, deselect
          piece.canvas.classList.remove("selected");
          firstSelected = null;
        } else {
          // Swap positions
          swapPieces(firstSelected, piece);
          firstSelected.canvas.classList.remove("selected");
          firstSelected = null;
          // Check if solved
          if (checkSolved()) {
            document.getElementById("message").innerText = "Congratulations! Puzzle solved!";
          }
        }
      }

      // Swap the grid positions (and on-screen positions) of two pieces
      function swapPieces(p1, p2) {
        let tempRow = p1.currentRow;
        let tempCol = p1.currentCol;
        p1.currentRow = p2.currentRow;
        p1.currentCol = p2.currentCol;
        p2.currentRow = tempRow;
        p2.currentCol = tempCol;

        // Update their canvas positions
        p1.canvas.style.left = (p1.currentCol * pieceWidth + bumpSize) + "px";
        p1.canvas.style.top  = (p1.currentRow * pieceHeight + bumpSize) + "px";
        p2.canvas.style.left = (p2.currentCol * pieceWidth + bumpSize) + "px";
        p2.canvas.style.top  = (p2.currentRow * pieceHeight + bumpSize) + "px";
      }

      // Check if all pieces are in their correct position
      function checkSolved() {
        for (let piece of piecesArray) {
          if (piece.currentRow !== piece.row || piece.currentCol !== piece.col) {
            return false;
          }
        }
        return true;
      }
    };
  </script>
</body>
</html>

